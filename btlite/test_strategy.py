# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_code
# $$_ %%checkall
from dataclasses import dataclass, field
import pandas as pd
import numpy as np
from typing import cast
import math
from types import SimpleNamespace
from btlite.bt_types import Trade, Order, Contract, TimeInForce
from btlite.strategy import Strategy, roundtrip_trades, get_pnl, get_pnl_df


class EntryRule:
    def __init__(self, prices: dict[np.datetime64, float]) -> None:
        self.prices = {('AAPL', timestamp): price for timestamp, price in prices.items()}
        self.order_id = 0

    def __call__(self, strategy: Strategy, timestamp: np.datetime64) -> list[Order]:
        if any([order.contract.symbol == 'AAPL' for order in strategy.live_orders]): return []
        curr_position = strategy.get_position('AAPL')
        if curr_position != 0: return []
        curr_equity = strategy.get_current_equity(timestamp, self.prices)
        est_price = self.prices[('AAPL', timestamp)]
        qty = np.floor((0.1 * curr_equity) / est_price)
        self.order_id += 1
        return [Order(
                order_id=f'enter_{self.order_id}', 
                contract=Contract.get_or_create('AAPL'), 
                timestamp=timestamp, 
                qty=qty, 
                reason_code='ENTER', 
                time_in_force=TimeInForce.FOK)]
    
    
@dataclass
class ExitRule:
    order_id: int = 0

    def __call__(self, strategy: Strategy, timestamp: np.datetime64) -> list[Order]:
        if any([order.contract.symbol == 'AAPL' for order in strategy.live_orders]): return []
        curr_position = strategy.get_position('AAPL')
        if curr_position == 0: return []
        live_orders = strategy.live_orders
        if any([order.qty < 0 for order in live_orders]): return []  # some other order is trying to exit
        self.order_id += 1
        return [Order(order_id=f'exit_{self.order_id}',
                      contract=Contract.get_or_create('AAPL'), 
                      timestamp=timestamp, 
                      qty=-curr_position, 
                      reason_code='EOD', 
                      time_in_force=TimeInForce.GTC)]
    

@dataclass
class StopRule:
    order_id: int = 0
    stop_price: float = math.nan
    prices: dict[np.datetime64, float] = field(default_factory=dict)

    def __call__(self, strategy: Strategy, timestamp: np.datetime64) -> list[Order]:
        if any([order.contract.symbol == 'AAPL' for order in strategy.live_orders]): return []
        curr_position = strategy.get_position('AAPL')
        if curr_position == 0: return []
        if any([order.qty < 0 for order in strategy.live_orders]): return []  # some other order is trying to exit
        price = self.prices[timestamp]
        if price >= self.stop_price:
            self.order_id += 1
            return [Order(
                    order_id=f'stop_{self.order_id}',
                    contract=Contract.get_or_create('AAPL'), 
                    timestamp=timestamp, 
                    qty=-curr_position, 
                    reason_code='STOP', 
                    time_in_force=TimeInForce.GTC)]
        return []
    
    
class TradeCallback:
    def __init__(self, prices: dict[np.datetime64, float]) -> None:
        self.prices = prices

    def __call__(self, strategy: Strategy, timestamp: np.datetime64, trade: Trade) -> None:
        if trade.qty < 0:  
            strategy.disable_rule('stop')
        else:
            stop_rule = cast(StopRule, strategy.rules['stop'])
            stop_rule.prices = self.prices
            stop_rule.stop_price = 12.
            strategy.enable_rule('stop')


class MarketSim:
    def __init__(self, prices: dict[np.datetime64, float]) -> None:
        self.prices = prices    

    def __call__(self, strategy: Strategy, timestamp: np.datetime64, orders: list[Order]) -> list[Trade]:
        trade_price = self.prices[timestamp]
        trades: list[Trade] = []
        for i, order in enumerate(orders):
            trade = Trade(order.contract, order, timestamp, order.qty, trade_price, properties=SimpleNamespace(trade_id=str(i)))
            trades.append(trade)
            order.fill()
        return trades


def get_prices(df: pd.DataFrame) -> dict[np.datetime64, float]:
    timestamps = df.timestamp.values.astype('M8[m]')
    c = df.c.values
    prices = {timestamps[i]: c[i] for i in range(len(timestamps))}
    return prices


def test_simple_strat() -> None:
    timestamps = np.arange(np.datetime64('2024-01-02 09:00'), np.datetime64('2024-01-02 09:06'))
    df = pd.DataFrame({'timestamp': timestamps})
    df['ret'] = [0.01, -0.01, 0.02, -0.005, 0.01, 0.03]
    df['c'] = (1 + df.ret).cumprod() * 10.
    df['date'] = df.timestamp.values.astype('M8[D]')
    df['eod'] = [False, False, False, True, True, True]
    strategy = Strategy()
    strategy.set_market_timestamps(timestamps)
    prices = get_prices(df)
    strategy.add_rule('entry', EntryRule(prices))
    strategy.add_rule('exit', ExitRule())
    strategy.enable_rule('entry', df[df.c > 10.15].timestamp.values.astype('M8[m]'))
    strategy.enable_rule('exit', df[df.eod].timestamp.values.astype('M8[m]'))
    strategy.add_market_sim(MarketSim(prices))
    strategy.run()


def test_stop_strat() -> None:
    timestamps = np.arange(np.datetime64('2024-01-02 09:00'), np.datetime64('2024-01-02 09:06'))
    df = pd.DataFrame({'timestamp': timestamps})
    df['ret'] = [0.01, 0.02, 0, 0.2, -0.01, 0.03]
    df['c'] = (1 + df.ret).cumprod() * 10.
    df['date'] = df.timestamp.values.astype('M8[D]')
    df['eod'] = [False, False, False, False, True, True]
    strategy = Strategy()
    strategy.set_market_timestamps(timestamps)
    prices = get_prices(df)
    strategy.add_rule('exit', ExitRule())
    strategy.add_rule('stop', StopRule())
    strategy.add_rule('entry', EntryRule(prices))
    strategy.add_trade_callback(TradeCallback(prices))
    strategy.enable_rule('entry', df[df.c > 10.15].timestamp.values.astype('M8[m]'))
    strategy.enable_rule('exit', df[df.eod].timestamp.values.astype('M8[m]'))

    strategy.add_market_sim(MarketSim(prices))
    strategy.run()

    _trades = roundtrip_trades(strategy.trade_history)
    pnl = get_pnl(_trades, np.array([np.datetime64('2024-01-02 15:59')]), {('AAPL', np.datetime64('2024-01-02 15:59')): np.nan})

    pnl_df = get_pnl_df(pnl)
    assert len(pnl_df) == 1
    row = pnl_df.iloc[0]
    assert math.isclose(row.unrealized, 0.)
    assert math.isclose(row.realized, 18798.347856)
    assert math.isclose(row.commission, 0.)
    strat_pnl = strategy.get_daily_pnl({('AAPL', np.datetime64('2024-01-02 15:59')): np.nan})
    row = strat_pnl.iloc[0]
    assert math.isclose(row.pnl, 18798.347856)


if __name__ == '__main__':
    test_simple_strat()
    test_stop_strat()
# $$_end_code
