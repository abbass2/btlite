# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_code
# $$_ %%checkall
from collections import deque
import copy
from dataclasses import dataclass, field
import pandas as pd
import pandas_market_calendars as mcal
import numpy as np
from typing import Callable, Any
import math
from types import SimpleNamespace
from collections import defaultdict
from btlite.bt_utils import get_child_logger, assert_
from btlite.bt_types import RoundTripTrade, Trade, Order, Contract, TimeInForce, OrderStatus, ModificationType


_logger = get_child_logger(__name__)


def _net_trade(stack: deque, trade: Trade) -> RoundTripTrade | None:
    if not len(stack) or np.sign(trade.qty) == np.sign(stack[0].qty):
        stack.append(trade)
        return None
    
    entry = stack[0]
    qty = min(abs(entry.qty), abs(trade.qty)) * np.sign(entry.qty)
    entry_fraction = abs(qty / entry.qty)
    exit_fraction = abs(qty / trade.qty)
    pnl = qty * (trade.price - entry.price) * entry.contract.multiplier - trade.commission * exit_fraction - entry.commission * entry_fraction
    entry_reason_code = entry.order.reason_code if entry.order else ''
    exit_reason_code = trade.order.reason_code if trade.order else ''
    rt = RoundTripTrade(entry.contract, 
                        entry.order, trade.order, 
                        entry.timestamp, trade.timestamp,
                        qty, 
                        entry.price, trade.price, 
                        entry_reason_code, exit_reason_code,
                        entry.commission * entry_fraction, trade.commission * exit_fraction,
                        copy.deepcopy(entry.properties), copy.deepcopy(trade.properties),
                        pnl)
    resid = entry.qty - qty
    entry.qty -= qty
    entry.commission *= (1 - entry_fraction)
    trade.qty += qty
    trade.commission *= (1 - exit_fraction)
    if resid == 0:
        stack.popleft()
    return rt


def roundtrip_trades(trades: list[Trade]) -> list[RoundTripTrade]:
    '''
    >>> qtys = [100, -50, 20, -120, 10]
    >>> prices = [9, 10, 8, 11, 12]                    
    >>> trades = []
    >>> contract = SimpleNamespace(symbol='AAPL', multiplier=1)
    >>> order = SimpleNamespace(reason_code='DUMMY')
    >>> for i, qty in enumerate(qtys):
    ...    timestamp = np.datetime64('2022-11-05 08:00') + np.timedelta64(i, 'm')
    ...    trades.append(Trade(contract, order, timestamp, qty, prices[i]))
    >>> rts = roundtrip_trades(trades)
    >>> assert [(rt.qty, rt.entry_price, rt.exit_price, rt.net_pnl) for rt in rts] == [
    ...    (50, 9, 10, 50.0), (50, 9, 11, 100.0), (20, 8, 11, 60.0), (-10, 11, 12, -10.0), (-40, 11, np.nan, 0.0)]
    '''
    rtt: list[RoundTripTrade] = []
    stacks: dict[str, deque] = defaultdict(deque)
    _trades = copy.copy(trades)
    
    # Keep track of index
    for i, trade in enumerate(_trades):
        trade.properties.index = i
        
    for _trade in _trades:
        trade = copy.copy(_trade)  # note this is a shallow copy so don't modify any objects
        while True:
            rt = _net_trade(stacks[trade.contract.symbol], trade)
            if rt is None: break
            rtt.append(rt)
            if trade.qty == 0: break
                
    open_trades = [trade for trades in stacks.values() for trade in trades]
        
    open_rtt = [RoundTripTrade(open_trade.contract,
                               open_trade.order, 
                               None,
                               open_trade.timestamp, 
                               np.datetime64('NaT'),
                               open_trade.qty,
                               open_trade.price, 
                               np.nan, 
                               open_trade.order.reason_code, 
                               None,
                               open_trade.commission, 
                               np.nan,
                               open_trade.properties, 
                               SimpleNamespace(),
                               0.) for open_trade in open_trades]
    rtt = rtt + open_rtt
    rtt.sort(key=lambda rt: rt.entry_properties.index)
    for i, rt in enumerate(rtt):
        rt.entry_properties.entry_index = rt.entry_properties.index
        rt.entry_properties.index = i
        
    return rtt


def df_roundtrip_trade(rt_trades: list[RoundTripTrade]) -> pd.DataFrame:
    df_rts = pd.DataFrame.from_records([dict(
        symbol=s.contract.symbol, 
        multiplier=s.contract.multiplier, 
        entry_timestamp=s.entry_timestamp,
        exit_timestamp=s.exit_timestamp,
        qty=s.qty,
        entry_price=s.entry_price,
        exit_price=s.exit_price,
        entry_reason=s.entry_reason,
        exit_reason=s.exit_reason,
        entry_commission=s.entry_commission,
        exit_commission=s.exit_commission,
        net_pnl=s.net_pnl) for s in rt_trades])
    if len(df_rts) > 0:
        df_rts = df_rts.sort_values(by=['entry_timestamp', 'symbol'])
    return df_rts


def get_trade_pnl(trade: RoundTripTrade, 
                  timestamps: np.ndarray, 
                  prices: dict[tuple[str, np.datetime64], float]) -> list[tuple[np.datetime64, float, float, float]]:
    '''
    >>> from types import SimpleNamespace
    >>> trade = SimpleNamespace(
    ... contract=SimpleNamespace(symbol='AAPL US', multiplier=1), 
    ... entry_timestamp=np.datetime64('2023-01-02'), 
    ... exit_timestamp=np.datetime64('2023-01-04'), 
    ... entry_price=99.,
    ... exit_price=105.,
    ... qty=10,
    ... entry_commission=10.,
    ... exit_commission=15.)
    >>> run_dates = np.array(['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-31'], dtype='M8[D]')
    >>> prices = {('AAPL US', np.datetime64('2023-01-01')): 100.,
    ...        ('AAPL US', np.datetime64('2023-01-02')): 101.,
    ...        ('AAPL US', np.datetime64('2023-01-03')): 102.,
    ...        ('AAPL US', np.datetime64('2023-01-31')): 103.}
    >>> trade_pnl = get_trade_pnl(trade, run_dates, prices)
    >>> assert len(trade_pnl) == 3 
    >>> assert trade_pnl[-1] == (np.datetime64('2023-01-31'), -30.0, 60.0, 25.0)
    '''
    entry_commission_applied = False
    symbol = trade.contract.symbol
 
    rows: list = []

    unrealized = 0.
    realized = 0.
    commission = 0.
    unrealized_mv = 0.

    for i, timestamp in enumerate(timestamps):
        if timestamp < trade.entry_timestamp: continue

        if not entry_commission_applied:
            commission += trade.entry_commission
            entry_commission_applied = True
        
        if timestamp >= trade.exit_timestamp:
            commission += trade.exit_commission
            realized = (trade.exit_price - trade.entry_price) * trade.contract.multiplier * trade.qty
            unrealized = -unrealized_mv
            rows.append((timestamp, unrealized, realized, commission))
            break

        price = prices.get((symbol, timestamp))
        if price is None:
            _logger.warning(f'could not find price for: {symbol} {timestamp}')
            price = np.nan

        _unrealized_mv = (price - trade.entry_price) * trade.contract.multiplier * trade.qty
        unrealized = _unrealized_mv - unrealized_mv  # current - previous
        unrealized_mv = _unrealized_mv
        rows.append((timestamp, unrealized, realized, commission))
    return rows


def get_pnl(trades: list[RoundTripTrade], 
            timestamps: np.ndarray, 
            prices: dict[tuple[str, np.datetime64], float]) -> list[tuple[str, np.datetime64, float, float, float]]:
    rows: list[tuple[str, np.datetime64, float, float, float]] = []
    for trade in trades:
        trade_pnl = get_trade_pnl(trade, timestamps, prices)
        for row in trade_pnl:
            rows.append((trade.entry_properties.trade_id, row[0], row[1], row[2], row[3]))
    return rows


def get_pnl_df(pnl: list[tuple[str, np.datetime64, float, float, float]]) -> pd.DataFrame:
    return pd.DataFrame.from_records(pnl, columns=['trade_id', 'timestamp', 'unrealized', 'realized', 'commission'])


def get_new_order_status(mod_type: ModificationType) -> OrderStatus:
    if mod_type == ModificationType.OPEN: return OrderStatus.OPEN
    if mod_type == ModificationType.CANCEL: return OrderStatus.CANCELLED
    assert_(False, f'invalid mod_type: {mod_type}')
    return OrderStatus.CANCELLED  # keep mypy happy


# will define Order in a types module
RuleType = Callable[[Any, [np.datetime64], list[Order]], list[Order]]  # type: ignore # noqa
MarketSimType = Callable[[Any, np.datetime64, list[Order]], list[Trade]]  # type: ignore # noqa
TradeCBType = Callable[[Any, np.datetime64, Trade], None]  # type: ignore # noqa


@dataclass
class Strategy:

    timestamps: np.ndarray
    rules: dict[str, RuleType]
    enabled_rules: defaultdict[np.datetime64, set[str]]
    globally_enabled_rules: set[str]
    market_sims: list[MarketSimType]
    trade_callbacks: list[TradeCBType]
    live_orders: list[Order]
    cancelled_orders: list[Order]
    filled_orders: list[Order]
    trade_history: list[Trade]
    trade_lag: np.timedelta64
    log_orders: bool
    log_trades: bool

    def __init__(self, initial_cash: float = 1e6, trade_lag: np.timedelta64 = np.timedelta64(1, 'm')) -> None:
        self.timestamps = np.ndarray(0)
        self.rules = {}
        self.enabled_rules = defaultdict(set)
        self.globally_enabled_rules = set()
        self.market_sims = []
        self.trade_callbacks = []
        self.live_orders = []
        self.cancelled_orders = []
        self.filled_orders = []
        self.trade_history = []
        self.trade_lag = trade_lag
        self.log_orders = True
        self.log_trades = True
        self.initial_cash = initial_cash
        self.account = Account(cash=initial_cash, positions=defaultdict(int))

    def set_market_timestamps(self, timestamps: np.ndarray) -> None:
        '''
        Use either this or set_market_calendar
        '''
        self.timestamps = timestamps

    def set_market_calendar(self, 
                            start_date: np.datetime64, 
                            end_date: np.datetime64, 
                            calendar: str = 'NYSE', 
                            tz: str = 'US/Eastern', 
                            freq: str = '1m') -> None:
        '''
        Closed on the left, i.e 9:30-15:59, not 9:31-16:00
        '''
        cal = mcal.get_calendar(calendar)
        assert_(cal is not None)
        schedule = cal.schedule(start_date, end_date)
        timestamps = mcal.date_range(schedule, frequency=freq, closed='left', force_close=False)
        timestamps = timestamps.tz_convert(tz).tz_localize(None).values
        if freq.endswith('m'):
            timestamps = timestamps.astype('M8[m]')
        elif freq.endswith('D'):
            timestamps = timestamps.astype('M8[D]')
        else:
            assert_(False, 'unknown frequency: {freq}')
        self.timestamps = timestamps

    def add_rule(self, name: str, rule: RuleType) -> None:
        '''Rules are guaranteed to be run in the order in which they are added here'''
        self.rules[name] = rule

    def enable_rule(self, name: str, timestamps: np.ndarray | None = None) -> None:

        if timestamps is None:
            self.globally_enabled_rules.add(name)
            return

        assert_(timestamps.dtype == self.timestamps.dtype)

        for timestamp in timestamps:
            rules_list = self.enabled_rules.get(timestamp)
            if rules_list is None:
                self.enabled_rules[timestamp] = {name}
            else:
                rules_list.add(name)

    def disable_rule(self, name: str) -> None:
        '''Call enable_rule if you want to disable for a few timestamps.'''
        self.globally_enabled_rules.discard(name)

    def add_market_sim(self, market_sim: MarketSimType) -> None:
        self.market_sims.append(market_sim)

    def add_trade_callback(self, trade_cb: TradeCBType) -> None:
        self.trade_callbacks.append(trade_cb)

    def get_current_equity(self, timestamp: np.datetime64, prices: dict[tuple[str, np.datetime64], float]) -> float:
        equity: float = self.account.cash
        for (name, qty) in self.account.positions.items():
            if qty == 0: continue
            price = prices.get((name, timestamp))
            if price is None:
                _logger.warning(f'could not find price for: {name} {timestamp}')
                return math.nan
            contract = Contract.get(name)
            assert contract is not None
            multiplier = contract.multiplier
            mv = price * qty * multiplier
            equity += mv
        return equity

    def _apply_mod_requests(self, timestamp: np.datetime64) -> None:
        for order in self.live_orders:
            if order.pending_mod is None: continue
            pending_mod = order.pending_mod
            if (timestamp - pending_mod.request_time) < self.trade_lag: continue
            order.status = get_new_order_status(pending_mod.modification_type)
            if np.isfinite(pending_mod.limit_price): order.limit_price = pending_mod.limit_price
            if pending_mod.qty != 0: order.qty = pending_mod.qty
            order.pending_mod = None
            
    def _expire_orders(self, timestamp: np.datetime64) -> None:
        for order in self.live_orders:
            if order.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED]:
                if order.time_in_force == TimeInForce.FOK and (timestamp - order.timestamp) > self.trade_lag:
                    order.status = OrderStatus.CANCELLED
                    continue
                if order.time_in_force == TimeInForce.DAY and timestamp.astype('M8[D]') > order.timestamp.astype('M8[D]'):
                    order.status = OrderStatus.CANCELLED
                    continue

    def _get_new_orders(self, timestamp: np.datetime64) -> list[Order]:
        new_orders: list[Order] = []
        rule_names = self.enabled_rules[timestamp]
        for rule_name, rule in self.rules.items():
            if rule_name in rule_names or rule_name in self.globally_enabled_rules:
                _new_orders = rule(self, timestamp, self.live_orders + new_orders)
                new_orders += _new_orders
                self.live_orders += _new_orders

        if self.log_orders:
            for order in new_orders: 
                _logger.info(f'ORDER: {order}')

        return new_orders

    def _update_order_lists(self) -> None:
        tmp: list[Order] = []
        for order in self.live_orders:
            if order.status == OrderStatus.FILLED:
                self.filled_orders.append(order)
                continue
            if order.status == OrderStatus.CANCELLED:
                self.cancelled_orders.append(order)
                continue
            tmp.append(order)
        self.live_orders = tmp

    def get_position(self, name: str) -> int:
        val = self.account.positions.get(name)
        if val is None: return 0
        return val

    def get_positions(self) -> dict[str, int]:
        return self.account.positions

    def run(self) -> None:
        for timestamp in self.timestamps:
            self._apply_mod_requests(timestamp)
            self._expire_orders(timestamp)
            self._update_order_lists()
            self._get_new_orders(timestamp)
 
            ready_orders = [order for order in self.live_orders if order.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED]]
            trades: list[Trade] = []

            for market_sim in self.market_sims:
                trades += market_sim(self, timestamp, ready_orders)

            if self.log_trades:
                for trade in trades:
                    _logger.info(f'TRADE: {trade}')

            for trade in trades:
                self.trade_history.append(trade)

            for trade in trades:
                self.account.update_cash(-trade.qty * trade.contract.multiplier * trade.price)
                self.account.update_position(trade.contract.symbol, trade.qty)

            for trade in trades:
                for trade_callback in self.trade_callbacks:
                    trade_callback(self, timestamp, trade)

    def get_daily_pnl(self, prices: dict[tuple[str, np.datetime64], float], pnl_time: int = 15 * 60 + 59) -> pd.DataFrame:
        timestamps = np.unique(self.timestamps.astype('M8[D]')) + np.timedelta64(pnl_time, 'm')
        trades = roundtrip_trades(self.trade_history)
        pnl = get_pnl(trades, timestamps, prices)
        df = pd.DataFrame.from_records(pnl, columns=['trade_id', 'timestamp', 'unrealized', 'realized', 'commission'])
        df['pnl'] = df.unrealized + df.realized + df.commission
        df = df[['timestamp', 'pnl', 'unrealized', 'realized', 'commission']].groupby('timestamp', as_index=False).sum()
        df['equity'] = self.initial_cash + df.pnl.cumsum()
        df['ret'] = df.equity.pct_change()
        return df


@dataclass
class Account:
    cash: float
    positions: defaultdict[str, int] = field(default_factory=lambda: defaultdict(int))

    def update_cash(self, add_amount: float) -> None:
        cash = self.cash
        cash += add_amount
        assert_(cash >= 0., f'cash cannot go below 0: {cash}')
        self.cash += add_amount
        _logger.debug(f'removed cash: {add_amount} new cash: {self.cash}')

    def update_position(self, name: str, add_amount: int) -> None:
        self.positions[name] += add_amount


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
# $$_end_code
