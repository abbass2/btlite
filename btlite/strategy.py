# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_code
# $$_ %%checkall
from dataclasses import dataclass, field
from sortedcontainers import SortedDict
import pyqstrat as pq
import pandas as pd
import pandas_market_calendars as mcal
import numpy as np
from typing import Callable
from enum import Enum
import math
from types import SimpleNamespace
from collections import defaultdict


# will define Order in a types module
RuleType = Callable[[Strategy, [np.datetime64]], list[Order]]  # type: ignore # noqa
MarketSimType = Callable[[Strategy, np.datetime64, list[Order]], list[pq.Trade]]  # type: ignore # noqa
TradeCBType = Callable[[Strategy, np.datetime64, pq.Trade], None]  # type: ignore # noqa


class OrderStatus(Enum):
    '''
    Enum for order status
    '''
    NEW = 1
    OPEN = 2
    PARTIALLY_FILLED = 3
    FILLED = 4
    CANCELLED = 5


class TimeInForce(Enum):
    FOK = 1  # Fill or Kill
    GTC = 2  # Good till Cancelled
    DAY = 3  # Cancel at EOD


class ModificationType(Enum):
    OPEN = 1
    CANCEL = 2


@dataclass
class ModRequest:
    modification_type: ModificationType
    request_time: np.datetime64


@dataclass(kw_only=True)
class Order:
    '''
    Args:
        contract: The contract this order is for
        timestamp: Time the order was placed
        qty:  Number of contracts or shares.  Use a negative quantity for sell orders
        reason_code: The reason this order was created. Default ''
        properties: Any order specific data we want to store.  Default None
        status: Status of the order, "open", "filled", etc. Default "open"
    '''
    contract: pq.Contract
    timestamp: np.datetime64 = np.datetime64()
    qty: float = math.nan
    reason_code: str = ''
    time_in_force: TimeInForce = TimeInForce.FOK
    properties: SimpleNamespace = field(default_factory=SimpleNamespace)
    status: OrderStatus = OrderStatus.NEW
    pending_mod: ModRequest | None = None

    def __post_init__(self) -> None:
        self.pending_mod = ModRequest(ModificationType.OPEN, self.timestamp)
        
    def request_modification(self, mod_request: ModRequest) -> None:
        self.pending_mod = mod_request
        
    def fill(self, fill_qty: float = math.nan) -> None:
        pq.assert_(self.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED], 
                   f'cannot fill an order in status: {self.status}')
        if math.isnan(fill_qty): fill_qty = self.qty
        pq.assert_(self.qty * fill_qty >= 0, f'order qty: {self.qty} cannot be opposite sign of {fill_qty}')
        pq.assert_(abs(fill_qty) <= abs(self.qty), f'cannot fill qty: {fill_qty} larger than order qty: {self.qty}')
        self.qty -= fill_qty
        if math.isclose(self.qty, 0):
            self.status = OrderStatus.FILLED
        else:
            self.status = OrderStatus.PARTIALLY_FILLED
        self.pending_mod = None
        

def get_new_order_status(mod_type: ModificationType) -> OrderStatus:
    if mod_type == ModificationType.OPEN: return OrderStatus.OPEN
    if mod_type == ModificationType.CANCEL: return OrderStatus.CANCELLED
    pq.assert_(False, f'invalid mod_type: {mod_type}')
    return OrderStatus.CANCELLED  # keep mypy happy


@dataclass
class Strategy:

    timestamps: np.ndarray
    rules: dict[str, RuleType]
    enabled_rules: SortedDict[np.datetime64, set[str]]
    globally_enabled_rules: set[str]
    market_sims: list[MarketSimType]
    trade_callbacks: list[TradeCBType]
    live_orders: list[Order]
    cancelled_orders: list[Order]
    filled_orders: list[Order]
    trade_lag: np.timedelta64

    def __init__(self, initial_cash: float = 1.e6, trade_lag: np.timedelta64 = np.timedelta64(1, 'm')) -> None:
        self.timestamps = np.ndarray(0)
        self.rules = {}
        self.enabled_rules = SortedDict()
        self.globally_enabled_rules = set()
        self.market_sims = []
        self.trade_callbacks = []
        self.live_orders = []
        self.cancelled_orders = []
        self.filled_orders = []
        self.trade_lag = np.timedelta64(1, 'm')
        self.account = Account(cash=initial_cash, positions=defaultdict())

    def set_market_timestamps(self, timestamps: np.ndarray) -> None:
        '''
        Use either this or set_market_calendar
        '''
        self.timestamps = timestamps

    def set_market_calendar(self, 
                            start_date: np.datetime64, 
                            end_date: np.datetime64, 
                            calendar: str = 'NYSE', 
                            tz: str = 'US/Eastern', 
                            freq: str = '1m') -> None:
        '''
        Closed on the left, i.e 9:30-15:59, not 9:31-16:00
        '''
        cal = mcal.get_calendar(calendar)
        pq.assert_(cal is not None)
        schedule = cal.schedule(start_date, end_date)
        timestamps = mcal.date_range(schedule, frequency=freq, closed='left', force_close=False).tz_localize(None).values
        if freq.endswith('m'):
            timestamps = timestamps.astype('M8[m]')
        elif freq.endswith('D'):
            timestamps = timestamps.astype('M8[D]')
        else:
            pq.assert_(False, 'unknown frequency: {freq}')
        self.timestamps = timestamps

    def add_rule(self, name: str, rule: RuleType) -> None:
        '''Rules are guaranteed to be run in the order in which they are added here'''
        self.rules[name] = rule

    def enable_rule(self, name: str, timestamps: np.ndarray | None) -> None:

        if timestamps is None:
            self.globally_enabled_rules.add(name)
            return

        pq.assert_(timestamps.dtype == self.timestamps.dtype)

        for timestamp in timestamps:
            rules_list = self.enabled_rules.get(timestamp)
            if rules_list is None:
                self.enabled_rules[timestamp] = {name}
            else:
                rules_list.add(name)

    def disable_rule(self, name: str) -> None:
        '''Call enable_rule if you want to disable for a few timestamps.'''
        self.globally_enabled_rules.remove(name)

    def add_market_sim(self, market_sim: MarketSimType) -> None:
        self.market_sims.append(market_sim)

    def get_current_equity(self, timestamp: np.datetime64, prices: dict[np.datetime64, float]) -> float:
        equity: float = self.account.cash
        for (name, qty) in self.account.positions.items():
            price = prices.get(timestamp)
            pq.assert_(price is not None, f'price missing for: {name} {timestamp}')
            assert price is not None  # keep mypy happy
            multiplier = pq.Contract.get(name).multiplier
            mv = price * qty * multiplier
            equity += mv
        return equity

    def _apply_mod_requests(self, timestamp: np.datetime64) -> None:
        for order in self.live_orders:
            if order.pending_mod is None: continue
            pending_mod = order.pending_mod
            if (timestamp - pending_mod.request_time) < self.trade_lag: continue
            order.status = get_new_order_status(pending_mod.modification_type)
            order.pending_mod = None
            
    def _expire_orders(self, timestamp: np.datetime64) -> None:
        for order in self.live_orders:
            if order.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED]:
                if order.time_in_force == pq.TimeInForce.FOK and (timestamp - order.timestamp) > self.trade_lag:
                    order.status = OrderStatus.CANCELLED
                    continue
                if order.time_in_force == pq.TimeInForce.DAY and timestamp.astype('M8[D]') > order.timestamp.astype('M8[D]'):
                    order.status = OrderStatus.CANCELLED
                    continue

    def _get_new_orders(self, timestamp: np.datetime64) -> list[Order]:
        new_orders: list[Order] = []
        rule_names = self.enabled_rules[timestamp]
        for rule_name, rule in self.rules.items():
            if rule_name in rule_names or rule_name in self.globally_enabled_rules:
                new_orders += rule(self, timestamp)
        return new_orders

    def _update_order_lists(self) -> list[Order]:
        tmp: list[Order] = []
        ready_orders: list[Order] = []
        for order in self.live_orders:
            if order.status == OrderStatus.FILLED:
                self.filled_orders.append(order)
                continue
            if order.status == OrderStatus.CANCELLED:
                self.cancelled_orders.append(order)
                continue
            if order.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED]:
                ready_orders.append(order)
            tmp.append(order)

        self.live_orders = tmp
        return ready_orders

    def get_position(self, name: str) -> float:
        val = self.account.positions.get(name)
        if val is None: return 0.
        return val

    def run(self) -> None:
        for timestamp in self.timestamps:
            self.live_orders += self._get_new_orders(timestamp)
            self._apply_mod_requests(timestamp)
            self._expire_orders(timestamp)
            ready_orders = self._update_order_lists()

            trades: list[pq.Trade] = []

            for market_sim in self.market_sims:
                trades += market_sim(self, timestamp, ready_orders)

            for trade in trades:
                self.account.update_cash(-trade.qty * trade.contract.multiplier * trade.price)
                self.account.update_position(trade.contract.symbol, trade.qty)

            for trade in trades:
                for trade_callback in self.trade_callbacks:
                    trade_callback(self, timestamp, trade)


@dataclass
class Account:
    cash: float
    positions: defaultdict[str, int] = field(default_factory=lambda: defaultdict(int))

    def update_cash(self, add_amount: float) -> None:
        cash = self.cash
        cash += add_amount
        pq.assert_(cash >= 0., f'cash cannot go below 0: {cash}')
        self.cash += add_amount

    def update_position(self, name: str, add_amount: int) -> None:
        self.positions[name] += add_amount


class EntryRule:
    def __init__(self, prices: dict[np.datetime64, float]) -> None:
        self.prices = prices

    def __call__(self, strategy: Strategy, timestamp: np.datetime64) -> list[Order]:
        curr_position = strategy.get_position('AAPL')
        if curr_position != 0: return []
        curr_equity = strategy.get_current_equity(timestamp, self.prices)
        est_price = self.prices[timestamp]
        qty = np.floor((0.1 * curr_equity) / est_price)
        contract = pq.Contract.get('AAPL')
        return [Order(contract=contract, timestamp=timestamp, qty=qty, reason_code='ENTER', time_in_force=TimeInForce.FOK)]
    
    
class ExitRule:
    def __call__(self, strategy: Strategy, timestamp: np.datetime64) -> list[Order]:
        curr_position = strategy.get_position('AAPL')
        if curr_position == 0: return []
        contract = pq.Contract.get('AAPL')
        return [Order(contract=contract, timestamp=timestamp, qty=-curr_position, reason_code='EOD', time_in_force=TimeInForce.GTC)]
    
    
class MarketSim:
    def __init__(self, prices: dict[np.datetime64, float]) -> None:
        self.prices = prices    

    def __call__(self, timestamp: np.datetime64, orders: list[Order]) -> list[pq.Trade]:
        trade_price = self.prices[timestamp]
        trades: list[pq.Trade] = []
        for order in orders:
            trade = pq.Trade(order.contract, order, timestamp, order.qty, trade_price)
            trades.append(trade)
        return trades


def get_prices(df: pd.DataFrame) -> dict[np.datetime64, float]:
    timestamps = df.timestamp.values.astype('M8[m]')
    c = df.c.values.astype('M8[m]')
    prices = {timestamps[i]: c[i] for i in range(len(timestamps))}
    return prices


if __name__ == '__mainx__':
    np.random.seed(0)
    cal = mcal.get_calendar('NYSE')
    schedule = cal.schedule('2024-01-02')
    timestamps = mcal.date_range(schedule, frequency='1m', closed='left', force_close=False).tz_localize(None).values
    df = pd.DataFrame({'timestamp': timestamps})
    df['ret'] = np.random.normal(0, 0.001, len(timestamps))
    df['c'] = (1 + df.ret).cumprod() * 10.
    df['date'] = df.timestamp.values.astype('M8[D]')
    df['eod'] = (df.date != df.date.shift(-1))
    strategy = Strategy()
    strategy.set_market_timestamps(timestamps)
    prices = get_prices(df)
    strategy.add_rule('entry', EntryRule(prices))
    strategy.add_rule('exit', ExitRule())
    strategy.enable_rule('entry', df[df.c > 10.5].timestamp.values.astype('M8[m]'))
    strategy.enable_rule('exit', df[df.eod].timestamp.values.astype('M8[m]'))
    strategy.run()
# $$_end_code
