# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_code
# $$_ %%checkall
from __future__ import annotations
import pandas as pd
import numpy as np
import types
import math
import datetime
from dataclasses import dataclass, field
from types import SimpleNamespace
from typing import ClassVar
from enum import Enum
from btlite.bt_utils import assert_, get_child_logger

_logger = get_child_logger(__name__)


def _format(obj: SimpleNamespace | None) -> str:
    if obj is None: return ''
    if len(obj.__dict__) == 0: return ''
    return str(obj)


@dataclass
class Contract:
    _instances: ClassVar[dict[str, Contract]] = {}
    symbol: str
    expiry: np.datetime64 | None
    multiplier: float
    components: list[tuple[Contract, float]]
    properties: SimpleNamespace

    '''A contract such as a stock, option or a future that can be traded'''
    @staticmethod
    def create(symbol: str, 
               expiry: np.datetime64 | None = None, 
               multiplier: float = 1., 
               components: list[tuple[Contract, float]] | None = None,
               properties: SimpleNamespace | None = None) -> 'Contract':
        '''
        Args:
            symbol: A unique string reprenting this contract. e.g IBM or ESH9
            expiry: In the case of a future or option, the date and time when the 
                contract expires.  For equities and other non expiring contracts, set this to None.  Default None.
            multiplier: If the market price convention is per unit, and the unit is not the same as contract size, 
                set the multiplier here. For example, for E-mini contracts, each contract is 50 units and the price is per unit, 
                so multiplier would be 50.  Default 1
            properties: Any data you want to store with this contract.
                For example, you may want to store option strike.  Default None
        '''
        assert_(isinstance(symbol, str) and len(symbol) > 0)
        assert_(symbol not in Contract._instances, f'Contract with symbol: {symbol} already exists')
        assert_(multiplier > 0)
        if components is None: components = []
        if properties is None: properties = types.SimpleNamespace()
        contract = Contract(symbol, expiry, multiplier, components, properties)
        Contract._instances[symbol] = contract
        return contract
    
    def is_basket(self) -> bool:
        return len(self.components) > 0
    
    @staticmethod
    def exists(name) -> bool:
        return name in Contract._instances
    
    @staticmethod
    def get(name) -> Contract | None:
        '''
        Returns an existing contrat or none if it does not exist
        '''
        return Contract._instances.get(name)
    
    @staticmethod
    def get_or_create(symbol: str, 
                      expiry: np.datetime64 | None = None, 
                      multiplier: float = 1., 
                      components: list[tuple[Contract, float]] | None = None,
                      properties: SimpleNamespace | None = None) -> Contract:
        if symbol in Contract._instances:
            contract = Contract._instances.get(symbol)
        else:
            contract = Contract.create(symbol, expiry, multiplier, components, properties)
        return contract  # type: ignore
    
    @staticmethod
    def clear_cache() -> None:
        '''
        Remove our cache of contract groups
        '''
        Contract._instances = dict()
        
    def __repr__(self) -> str:
        return f'{self.symbol}' + (f' {self.multiplier}' if self.multiplier != 1 else '') + (
            f' expiry: {self.expiry.astype(datetime.datetime):%Y-%m-%d %H:%M:%S}' if self.expiry is not None else '') + (
            f' {_format(self.properties)}')
    

class OrderStatus(Enum):
    '''
    Enum for order status
    '''
    NEW = 1
    OPEN = 2
    PARTIALLY_FILLED = 3
    FILLED = 4
    CANCELLED = 5


class TimeInForce(Enum):
    FOK = 1  # Fill or Kill
    GTC = 2  # Good till Cancelled
    DAY = 3  # Cancel at EOD


class ModificationType(Enum):
    OPEN = 1
    CANCEL = 2


@dataclass
class ModRequest:
    modification_type: ModificationType
    request_time: np.datetime64
    qty: int = 0
    limit_price: float = np.nan


@dataclass(kw_only=True)
class Order:
    '''
    Args:
        contract: The contract this order is for
        timestamp: Time the order was placed
        qty:  Number of contracts or shares.  Use a negative quantity for sell orders
        limit_price: Limit price for the order
        reason_code: The reason this order was created. Default ''
        properties: Any order specific data we want to store.  Default None
        status: Status of the order, "open", "filled", etc. Default "open"
    '''
    order_id: str
    contract: Contract
    timestamp: np.datetime64 = np.datetime64()
    qty: int = 0
    remaining_qty: int = 0
    limit_price: float = math.nan
    reason_code: str = ''
    time_in_force: TimeInForce = TimeInForce.FOK
    properties: SimpleNamespace = field(default_factory=SimpleNamespace)
    status: OrderStatus = OrderStatus.NEW
    pending_mod: ModRequest | None = None

    def __post_init__(self) -> None:
        self.pending_mod = ModRequest(ModificationType.OPEN, self.timestamp)
        self.remaining_qty = self.qty
        
    def request_modification(self, mod_request: ModRequest) -> None:
        self.pending_mod = mod_request
        
    def fill(self, fill_qty: int = 0) -> None:
        assert_(self.status in [OrderStatus.OPEN, OrderStatus.PARTIALLY_FILLED], 
                f'cannot fill an order in status: {self.status}')
        if fill_qty == 0: fill_qty = self.remaining_qty
        assert_(self.remaining_qty * fill_qty >= 0, f'order qty: {self.qty} cannot be opposite sign of {fill_qty}')
        assert_(abs(fill_qty) <= abs(self.remaining_qty), f'cannot fill qty: {fill_qty} larger than remaining qty: {self.remaining_qty}')
        self.remaining_qty -= fill_qty
        if self.remaining_qty == 0:
            self.status = OrderStatus.FILLED
        else:
            self.status = OrderStatus.PARTIALLY_FILLED
        self.pending_mod = None

    def __repr__(self) -> str:
        msg = (f'{self.reason_code} {self.contract.symbol} {self.timestamp} qty: {self.qty} limit: {self.limit_price}'
               f' status: {self.status.name} tif: {self.time_in_force.name}')
        if self.pending_mod is not None:
            msg += f' pending_mod: {self.pending_mod.modification_type.name}'
        if len(self.properties.__dict__):
            msg += f' props: {self.properties}'
        return msg
            

class Trade:
    def __init__(self, contract: Contract,
                 order: Order,
                 timestamp: np.datetime64, 
                 qty: int, 
                 price: float, 
                 fee: float = 0., 
                 commission: float = 0., 
                 properties: SimpleNamespace | None = None) -> None:
        '''
        Args:
            contract: The contract we traded
            order: A reference to the order that created this trade. Default None
            timestamp: Trade execution datetime
            qty: Number of contracts or shares filled
            price: Trade price
            fee: Fees paid to brokers or others. Default 0
            commision: Commission paid to brokers or others. Default 0
            properties: Any data you want to store with this contract.
                For example, you may want to store bid / ask prices at time of trade.  Default None
        '''
        # assert(isinstance(contract, Contract))
        # assert(isinstance(order, Order))
        assert_(np.isfinite(qty))
        assert_(np.isfinite(price))
        assert_(np.isfinite(fee))
        assert_(np.isfinite(commission))
        # assert(isinstance(timestamp, np.datetime64))
        
        self.contract = contract
        self.order = order
        self.timestamp = timestamp
        self.qty = qty
        self.price = price
        self.fee = fee
        self.commission = commission
        
        if properties is None:
            properties = types.SimpleNamespace()
        self.properties = properties
        
    def __repr__(self) -> str:
        '''
        >>> Contract.clear_cache()
        >>> contract = Contract.create('IBM')
        >>> order = MarketOrder(contract=contract, timestamp=np.datetime64('2019-01-01T14:59'), qty=100)
        >>> print(Trade(contract, order, np.datetime64('2019-01-01 15:00'), 100, 10.2130000, 0.01))
        IBM 2019-01-01 15:00:00 qty: 100 prc: 10.213 fee: 0.01 order: IBM 2019-01-01 14:59:00 qty: 100 OrderStatus.OPEN
        '''
        timestamp = pd.Timestamp(self.timestamp).to_pydatetime()
        fee = f'fee: {self.fee:.6g}' if self.fee else ''
        commission = f'commission: {self.commission:.6g}' if self.commission else ''
        return (f'{self.contract.symbol} {_format(self.contract.properties)} {timestamp:%Y-%m-%d %H:%M:%S}'
                f' qty: {self.qty} prc: {self.price:.6g} {fee} {commission} order: {self.order} {_format(self.properties)}')
    

@dataclass
class RoundTripTrade:
    contract: Contract
    entry_order: Order
    exit_order: Order | None
    entry_timestamp: np.datetime64
    exit_timestamp: np.datetime64
    qty: int
    entry_price: float
    exit_price: float
    entry_reason: str | None
    exit_reason: str | None
    entry_commission: float
    exit_commission: float
    entry_properties: SimpleNamespace = field(default_factory=SimpleNamespace)
    exit_properties: SimpleNamespace = field(default_factory=SimpleNamespace)
    net_pnl: float = np.nan
    
    
if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE)
# $$_end_code
